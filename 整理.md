### 编译系统
编译系统由四部分构成:
预处理器，编译器，汇编器，链接器

##### 预处理器
delete comments, include other files, perform macro substitutions.

##### 编译器
A language translator. It executes the source program immediately. Depending on the 
language in use and the situation 

◆Assemblers
A translator translates assembly language into object code
◆Linkers
Collects code separately compiled or assembled in different object files into a file.
Connects the code for standard library functions.
Connects resources supplied by the operating system of the computer.


分析/前端负责知道高级语言，综合/后端负责生成机器语言

lexical analyzer词法分析器 负责看懂单词,让机器知道什么是单词。唯一接触源语言的。把标识符信息放入符号表。
syntax analyzer 语法分析器 创造语义结构，判断句子语病。判断句子是否合法。
semantic analyzer 建立高级语言到机器语言的映射


正则表达式是上下文无关文法的子集。


A token （单词）describes a pattern of characters having some meaning in the source program. (such as identifiers, operators, keywords, numbers, delimeters and so on)


### 单词四要素

名字token: identifier的名字。字符串公共集合的分类。scanner中的逻辑单元。
比如 \<Identifier\>, \<number\>。

规则pattern：描述单词字符串集合
比如Recall File and OS Wildcards ([A-Z]*. *)

词素lexeme：例子。符合模式且被单词分类的字符的实际序列。lexeme是token的实例。pattern是lexeme的集合。
比如 x,i,name

属性attribute:单词中除了词素外的信息
语义规则表示属性的依赖关系
词法分析器不需要知道属性，属性等到语义分析才需要。

单词影响parsing decision，属性影响单词翻译。
正则表达式是单词的一种规则


#### 语言相关
语言是固定字母表上的字符串集合。
字母表是符号的有限集合。
字符串是确定顺序的符号
> 有限确定自动机不允许有空  
> $\empty$ 表示空语言
> {$\epsilon$} 表示空串组成的集合

把有限算子扩充成无限语言的方法——结构归纳法
正则表达式就是结构归纳法定义的。



### 后缀表达式

#### 中缀转后缀
建立符号栈
顺序扫描中缀表达式
a） 数字直接输出
b） 是运算符
i : “(” 直接入栈
ii : “)” 将符号栈中的元素依次出栈并输出, 直到 “(“, “(“只出栈, 不输出
iii:  从栈顶开始把比当前符号优先级高的符号都出栈。将当前符号入栈。
扫描完后, 将栈中剩余符号依次输出

#### 后缀到中缀
顺序扫描后缀表达式
将数字压栈，如果遇到操作符，就弹出两个数字。与运算符构成一个算式，作为一个整体再次压入栈。
以此类推。

## 从RE到DFA

不确定性：
1.可以什么都不做就到达下一个状态
2.可以在相同动作下到达不同的状态

可以采用状态迁移图和状态迁移表表示，但图需要start和双圆圈；表需要标注start state和final state

DFA中不允许 $\epsilon \  move$
$S×\sum→S$
### RE → NFA → DFA
RE → NFA 汤普森构造法
NFA → DFA 子集构造法

<table>
<th>
    <td>空间复杂度</td>
    <td>时间复杂度</td>
</th>
<tr>
    <td>NFA</td>
    <td>O(正则表达式长度)</td>
    <td>O(正则表达式长度*输入长度)</td>
</tr>
<tr>
    <td>DFA</td>
    <td>O(2^正则表达式长度)</td>
    <td>O(输入长度)</td>
</tr>
</table>

#### 汤普森构造法
按照定式拼接
a|b
![a|b](1.png)

(a|b)*
![(a|b)*](2.png)

#### 子集构造法：

$$
\epsilon - closure(num)表示从num状态经过\epsilon可到达的状态 \\
1.从起始状态开始，找到起始状态经过\epsilon 可到达的所有状态记作S_0。 \\ 
2.对于其中的一个转移字符char，求\epsilon - closure(move(S_0,char))，表示对S_0中所有状态进行char字符的迁移能够得到的状态得到\epsilon - closure(num_1,num_2,...) \\
3.求出\epsilon - closure(num_1,num_2,...)的结果，如果与之前的S_0不同，则记作S_1 \\
4.对每个转移字符char都求\epsilon - closure(move(S_0,char))，得到S_2,S_3,... \\
5.对所有S_i进行2，3，4操作，直到没有新的S_i出现。
6.把所有的S_i构造状态迁移表，S_i作列头，转移字符作行头
$$

### RE → DFA
#### 直接构造法
内部节点都是算子

$$
1.把正则表达式加上\#。 \\
2.把非空字符按顺序做索引1，2，3... \\
3.构建树 \\
4.对所有的索引index都计算followpos(index) \\
5.把firstpos(root)作为S_0 \\ 
6.对所有在S_0字符char，followpos(char)，若有相同则求并集得到S_1,S_2,... \\
7.对S_1,S_2,...采用第6步，直到没有新状态为止。
$$

followpos：followpos(num)表示num代表的字符后面可接的字符的索引。
firstpos(root)表示可以直接达到的索引

◆ firstpos(n) -- the set of the positions of the first symbols of strings generated by the sub-expression rooted by n.
◆ lastpos(n) -- the set of the positions of the last symbols of strings generated by the sub-expression rooted by n.
◆ nullable(n) -- true if the empty string is a member of strings generated by the sub-expression rooted by n.

#### 最小化DFA
1.先把所有状态看作状态G，G1表示可以接受的状态（可终止状态），G2表示不可接受的状态。
2.根据识别字母能否区别其他状态来区分，若多个状态输入相同字母都进行相同操作则看作一个状态。


### 上下文无关文法
语法解析的基础。

特征：
– 一个有限的终结符集合
– 一个有限的非终结符集合
– 一个有限的产生式集合（且所有产生式左边只有一个非终结符，右边是终结符，非终结符，空串的组合）
– 一个非终结符作为起始符 

产生式：
需要把|的都分开算，并不是一行算一个。
非终结符：出现在箭头左边的。
终结符：除了终结符之外的。

可以由上下文无关文法产生的语言叫上下文无关语言。

### 句子、句型、句柄区别

句子
箭头右边全部是由终结符组成的字符串。
句型
箭头右边如果有非终结符，则是句型。句子是没有非终结符的句型。
句柄

等价语法：两个语法能产生相同的语言


### 解决左递归









### goto operation

1.





### FIRST集与FOLLOW集

#### FIRST集求法

1.FIRST集中推导右边第一个终结符一定是终结符，先把能算的非终结符都算了。注意要包含$\epsilon$。

2.如果推导右边第一个非终结符能推出$\epsilon$，那么还要加上第二个符号的FIRST集并以此类推。

3.把剩下的终结符求了。



#### FOLLOW集求法

1.先把$加入起始符的FOLLOW集中。

2.对于一个式子A→αBβ，除了$\epsilon$外所有在FIRST(β)里的东西都在FOLLOW(B)里。

3.如果FIRST(β)里有$\epsilon$或者没有β，那么所有在FOLLOW(A)里的东西都在FOLLOW(B)里。



## LL1文法

### LL1语法分析表

#### 构造LL1分析表

1.先求出FIRST和FOLLOW集

2.如果终结符a在FIRST(α)中，第A行α列为A→α

3.如果$\epsilon$在FIRST(α)中，那么把A→α加入第A行b列（b为FOLLOW(A)中所有终结符）。如果$在FOLLOW(A)中，那么把A→α加入第A行\$列



#### 判断是否是LL1文法

1.先看有无左递归，若有则不是。



#### 判断

1.先看有无左递归。若有则不是。

2.再看有无二义性，若有则不是。

3.构造LL1语法分析表，若有冲突则不是。



# 自底向上

内核项：包括S'→.S以及点不在最左端的所有项。

非内核项：除了S'→.S之外点在最左端的所有项。



## SLR文法

### 构造SLR分析表

先增加一个产生式S'→S

#### 闭包求法closure operation

1.先加入自己

2.把将要分析的（即.右边的）非终结符作为推导左边的推导加入闭包，重复该步骤直到没有新的推导加入



#### 构建集族

1.把所有|拆成几个推导式

2.I0是S'→S的闭包，并在所有的推导右侧加上.

3.移动.遍历推导，通过字符不同走向不同状态

4.遍历过程中如果.移动到了非终结符前，则需要加入该非终结符推导的闭包。

5.如果有重复状态，则只需要移动到旧状态即可。



#### 根据集族构造goto table

1.看所有转移为非终结符的转移，从状态i通过非终结符A转移到状态j，则goto第i行列A为j



#### 根据集族构造action table

1.看所有转移为终结符的转移，如果从状态i通过终结符a转移到状态j，那么在action表第i行列a处为s j

2.如果状态i有.在推导最右的推导式x（x为序号），若该推导为S'→S，则在action表第i行列$处为acc；若为其他推导，则求该推导左边非终结符A的FOLLOW集FOLLOW(A)，在第i行FOLLOW(A)里所有列处为r x



#### 验证SLR文法

需要构造SLR语法分析表，如果没有冲突就是SLR文法，否则不是。



## LR1文法

### 构造LR1分析表

#### 闭包求法

1.对于S'→S，则向前看标志为$

2.对于A→BC，a    ，B→D，那么B→D的向前看标志为FIRST(Ca)。 这步需要慢做，尤其搞清楚谁是B！

3.输入字符移动时，向前看标志不变。

4.注意向前看标志不同，算不同闭包。有些



#### 根据集族构造goto table

1.看所有转移为非终结符的转移，从状态i通过非终结符A转移到状态j，则goto第i行列A为j



#### 根据集族构造action table

1.看所有转移为终结符的转移，如果从状态i通过终结符a转移到状态j，那么在action表第i行列a处为s j

2.如果状态i有.在推导最右的推导式x（x为序号），若该推导为S'→S，则在action表第i行列$处为acc；若为其他推导，则action表第i行列a处为r x



## LALR文法



同心核：



## 语法制导定义

### 继承属性和综合属性

如果语义规则里的属性是终结符的属性，那么一定是综合属性。

对于产生式A→BC，语义规则只有等号左边的属性才能进行判断。如果是A.prop=B.prop或A.prop=C.prop，那么A的prop为综合属性；否则是继承属性。







若语义规则 A.prop=B.prop，则A的prop为综合属性；若语义规则 B.prop=A.prop，则B的prop为综合属性；若语义规则 B.prop=A.prop，则B的prop为继承属性。即等号右边的变量不能是等号左边变量推导式中右边的变量。





属性文法

从base开始




复习

第1章，第3-6章重点
第7章 运行时环境怎么构造。需要的部分。设计的基本原则
第8章 如何参数传递？中间代码生成：三地址代码，三地址代码的应用

编译器与编译系统？
前端与后端？什么时候分前端后端？什么时候分词法语法？为什么呢


考试题型
选择，填空（核心概念）
简答（实施细节：预处理+小算法如解决左递归，找句柄，二义性等）
计算（九大算法+三地址代码）
